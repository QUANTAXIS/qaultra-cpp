# QAULTRA C++ ä¸­æ–‡ä½¿ç”¨æŒ‡å—

## ğŸ“– ç›®å½•

- [ç³»ç»Ÿæ¶æ„](#ç³»ç»Ÿæ¶æ„)
- [å®‰è£…æŒ‡å—](#å®‰è£…æŒ‡å—)
- [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
- [æ¨¡å—è¯¦è§£](#æ¨¡å—è¯¦è§£)
- [APIå‚è€ƒ](#apiå‚è€ƒ)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

QAULTRA C++ é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œä¸»è¦ç»„ä»¶åŒ…æ‹¬ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Python API    â”‚    â”‚   C++ æ ¸å¿ƒ      â”‚    â”‚   åŸç”Ÿåº“        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ è´¦æˆ·ç®¡ç†      â”‚â—„â”€â”€â–ºâ”‚ â€¢ QA_Account    â”‚â—„â”€â”€â–ºâ”‚ â€¢ Apache Arrow  â”‚
â”‚ â€¢ ç­–ç•¥å¼€å‘      â”‚    â”‚ â€¢ MatchEngine   â”‚    â”‚ â€¢ Intel TBB     â”‚
â”‚ â€¢ å›æµ‹åˆ†æ      â”‚    â”‚ â€¢ MarketData    â”‚    â”‚ â€¢ mimalloc      â”‚
â”‚ â€¢ æ•°æ®åˆ†æ      â”‚    â”‚ â€¢ åè®®æ”¯æŒ      â”‚    â”‚ â€¢ SIMD å†…åœ¨å‡½æ•° â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒæ¨¡å—

#### ğŸ¦ è´¦æˆ·ç³»ç»Ÿ (`qaultra::account`)
- **QA_Account**: ä¸»è¦äº¤æ˜“è´¦æˆ·ç±»ï¼Œæ”¯æŒè‚¡ç¥¨å’ŒæœŸè´§äº¤æ˜“
- **Position**: å¤šèµ„äº§æŒä»“è·Ÿè¸ªï¼Œå®æ—¶ç›ˆäºè®¡ç®—
- **Order**: è®¢å•ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œæ”¯æŒå¤šç§è®¢å•ç±»å‹
- **MarketPreset**: å¸‚åœºç‰¹å®šé…ç½®ï¼Œæ‰‹ç»­è´¹å’Œä¿è¯é‡‘è®¾ç½®

#### ğŸ“Š å¸‚åœºæ•°æ® (`qaultra::market`)
- **MatchingEngine**: é«˜æ€§èƒ½è®¢å•æ’®åˆå¼•æ“
- **OrderBook**: Level-2å¸‚åœºæ·±åº¦æ•°æ®
- **MarketDataFeed**: å®æ—¶æ•°æ®æ¥å…¥
- **MarketSimulator**: å›æµ‹å¸‚åœºæ¨¡æ‹Ÿ

#### ğŸ’¾ æ•°æ®ç»“æ„ (`qaultra::data`)
- **ArrowKlineCollection**: åˆ—å¼OHLCVæ•°æ®å­˜å‚¨
- **KlineCollection**: ä¼ ç»ŸKçº¿æ•°æ®å­˜å‚¨
- **MarketDataManager**: å¤šæ ‡çš„æ•°æ®ç®¡ç†

#### ğŸ”Œ åè®®æ”¯æŒ (`qaultra::protocol`)
- **QIFI**: è´¦æˆ·å’ŒæŠ•èµ„ç»„åˆåºåˆ—åŒ–
- **MIFI**: å¸‚åœºæ•°æ®æ ¼å¼
- **TIFI**: äº¤æ˜“ä¿¡æ¯äº¤æ¢

## ğŸ“¦ å®‰è£…æŒ‡å—

### ç³»ç»Ÿè¦æ±‚

- **C++20** å…¼å®¹ç¼–è¯‘å™¨ (GCC 10+, Clang 12+, MSVC 2019+)
- **CMake** 3.20 æˆ–æ›´é«˜ç‰ˆæœ¬
- **Python** 3.8+ (ç”¨äºPythonç»‘å®š)

### Ubuntu/Debian å®‰è£…

```bash
# 1. å®‰è£…ç³»ç»Ÿä¾èµ–
sudo apt-get update
sudo apt-get install -y \
    build-essential \
    cmake \
    ninja-build \
    pkg-config \
    libtbb-dev \
    libssl-dev \
    python3-dev \
    python3-pip

# 2. å…‹éš†ä»“åº“
git clone https://github.com/quantaxis/qaultra-cpp.git
cd qaultra-cpp

# 3. åˆ›å»ºæ„å»ºç›®å½•
mkdir build && cd build

# 4. é…ç½®CMake (å¯ç”¨æ‰€æœ‰ä¼˜åŒ–)
cmake .. \
    -DCMAKE_BUILD_TYPE=Release \
    -DQAULTRA_ENABLE_SIMD=ON \
    -DQAULTRA_ENABLE_NATIVE=ON \
    -DQAULTRA_ENABLE_LTO=ON \
    -DQAULTRA_BUILD_PYTHON_BINDINGS=ON \
    -G Ninja

# 5. ç¼–è¯‘
ninja -j$(nproc)

# 6. å®‰è£…PythonåŒ…
pip install -e python/
```

### macOS å®‰è£…

```bash
# 1. å®‰è£…Homebrewä¾èµ–
brew install cmake ninja tbb python@3.11

# 2. è®¾ç½®ç¼–è¯‘ç¯å¢ƒ
export CXX=clang++
export CC=clang

# 3. æŒ‰ç…§ä¸Šè¿°Ubuntuæ­¥éª¤ç»§ç»­
```

### Windows (MSVC) å®‰è£…

```batch
# 1. å®‰è£…Visual Studio 2019/2022
# 2. å®‰è£…CMakeå’Œvcpkg

# 3. ä½¿ç”¨vcpkgå®‰è£…ä¾èµ–
vcpkg install tbb:x64-windows arrow:x64-windows

# 4. é…ç½®å’Œæ„å»º
cmake -B build -DCMAKE_TOOLCHAIN_FILE=vcpkg/scripts/buildsystems/vcpkg.cmake
cmake --build build --config Release
```

### Dockerå®‰è£…

```bash
# ä½¿ç”¨å®˜æ–¹Dockeré•œåƒ
docker pull quantaxis/qaultra-cpp:latest

# æˆ–æ„å»ºæœ¬åœ°é•œåƒ
docker build -t qaultra-cpp .
docker run -it qaultra-cpp bash
```

## ğŸš€ å¿«é€Ÿå¼€å§‹

### C++åŸºç¡€ç”¨æ³•

```cpp
#include "qaultra/qaultra.hpp"

using namespace qaultra;

int main() {
    // 1. åˆ›å»ºäº¤æ˜“è´¦æˆ·
    auto account = std::make_shared<account::QA_Account>(
        "æˆ‘çš„è´¦æˆ·",           // è´¦æˆ·ID
        "æŠ•èµ„ç»„åˆ1",         // ç»„åˆID
        "ç”¨æˆ·123",           // ç”¨æˆ·ID
        1000000.0,          // åˆå§‹èµ„é‡‘ (100ä¸‡)
        false,              // æ˜¯å¦è‡ªåŠ¨è¡¥ä»“
        "backtest"          // ç¯å¢ƒç±»å‹ (backtest/real)
    );

    std::cout << "åˆå§‹èµ„é‡‘: ï¿¥" << account->get_cash() << std::endl;

    // 2. æ‰§è¡Œä¹°å…¥æ“ä½œ
    auto buy_order = account->buy(
        "000001",           // è‚¡ç¥¨ä»£ç 
        1000.0,            // ä¹°å…¥æ•°é‡
        "2024-01-15 09:30:00", // äº¤æ˜“æ—¶é—´
        10.50              // ä¹°å…¥ä»·æ ¼
    );

    std::cout << "è®¢å•çŠ¶æ€: " << static_cast<int>(buy_order->status) << std::endl;
    std::cout << "è´¦æˆ·ä½™é¢: ï¿¥" << account->get_cash() << std::endl;

    // 3. ä»·æ ¼æ›´æ–°
    account->on_price_change("000001", 11.00, "2024-01-15 15:00:00");

    std::cout << "æµ®åŠ¨ç›ˆäº: ï¿¥" << account->get_float_profit() << std::endl;
    std::cout << "æ€»èµ„äº§: ï¿¥" << account->get_total_value() << std::endl;

    // 4. å¯¼å‡ºQIFIæ ¼å¼
    auto qifi_data = account->to_qifi();
    std::cout << "æŒä»“æ•°é‡: " << qifi_data.positions.size() << std::endl;

    return 0;
}
```

### Pythoné«˜çº§ç”¨æ³•

```python
import qaultra_cpp as qa
import numpy as np
import pandas as pd

# 1. åˆ›å»ºè´¦æˆ·
account = qa.account.QA_Account(
    account_cookie="pythonè´¦æˆ·",
    portfolio_cookie="pythonç»„åˆ",
    user_cookie="pythonç”¨æˆ·",
    init_cash=1000000.0,
    auto_reload=False,
    environment="backtest"
)

print(f"åˆå§‹èµ„é‡‘: ï¿¥{account.get_cash():,.2f}")

# 2. åˆ›å»ºArrow Kçº¿æ•°æ®
klines = qa.data.ArrowKlineCollection()

# ç”Ÿæˆç¤ºä¾‹æ•°æ®
dates = pd.date_range('2024-01-01', periods=100, freq='D')
codes = ["000001"] * 100
timestamps = [int(d.timestamp() * 1000) for d in dates]

# æ¨¡æ‹Ÿä»·æ ¼æ•°æ®
np.random.seed(42)
prices = 10.0 + np.cumsum(np.random.normal(0, 0.1, 100))
opens = prices
closes = prices + np.random.normal(0, 0.05, 100)
highs = np.maximum(opens, closes) + np.abs(np.random.normal(0, 0.1, 100))
lows = np.minimum(opens, closes) - np.abs(np.random.normal(0, 0.1, 100))
volumes = np.random.uniform(100000, 500000, 100)
amounts = closes * volumes

# æ·»åŠ åˆ°Arrowé›†åˆ
klines.add_batch(codes, timestamps, opens.tolist(), highs.tolist(),
                lows.tolist(), closes.tolist(), volumes.tolist(), amounts.tolist())

print(f"Kçº¿æ•°æ®æ¡æ•°: {klines.size()}")

# 3. æŠ€æœ¯æŒ‡æ ‡è®¡ç®—(SIMDä¼˜åŒ–)
sma_20 = klines.sma(20)  # 20æ—¥ç®€å•ç§»åŠ¨å¹³å‡
ema_12 = klines.ema(0.154)  # 12æ—¥æŒ‡æ•°ç§»åŠ¨å¹³å‡ (alpha=2/(12+1))
rsi_14 = klines.rsi(14)  # 14æ—¥RSI

print(f"SMA(20)æœ€æ–°å€¼: {sma_20[-1]:.2f}")
print(f"EMA(12)æœ€æ–°å€¼: {ema_12[-1]:.2f}")
print(f"RSI(14)æœ€æ–°å€¼: {rsi_14[-1]:.2f}")

# 4. æ‰§è¡Œäº¤æ˜“
current_price = closes[-1]
buy_order = account.buy("000001", 1000, "2024-04-10 09:30:00", current_price)

print(f"ä¹°å…¥è®¢å•: {1000}è‚¡ @ ï¿¥{current_price:.2f}")
print(f"è®¢å•çŠ¶æ€: {buy_order.status}")

# 5. ä»·æ ¼æ›´æ–°å’Œç›ˆäºè®¡ç®—
new_price = current_price * 1.05  # ä¸Šæ¶¨5%
account.on_price_change("000001", new_price, "2024-04-10 15:00:00")

print(f"ä»·æ ¼æ›´æ–°: ï¿¥{current_price:.2f} â†’ ï¿¥{new_price:.2f}")
print(f"æµ®åŠ¨ç›ˆäº: ï¿¥{account.get_float_profit():,.2f}")
print(f"æ€»èµ„äº§: ï¿¥{account.get_total_value():,.2f}")

# 6. æ€§èƒ½æµ‹è¯• - SIMD vs æ ‡å‡†å®ç°
size = 1000000
a = np.random.random(size)
b = np.random.random(size)

import time

# æ ‡å‡†NumPy
start = time.time()
numpy_result = a * b
numpy_time = time.time() - start

# SIMDä¼˜åŒ–
start = time.time()
simd_result = qa.simd.vectorized_multiply(a, b)
simd_time = time.time() - start

print(f"\næ€§èƒ½å¯¹æ¯” ({size:,}ä¸ªå…ƒç´ ):")
print(f"NumPyå®ç°: {numpy_time:.4f}ç§’")
print(f"SIMDå®ç°: {simd_time:.4f}ç§’")
print(f"æ€§èƒ½æå‡: {numpy_time/simd_time:.2f}å€")
```

## ğŸ”§ å›æµ‹ç¤ºä¾‹

### ç®€å•ç§»åŠ¨å¹³å‡ç­–ç•¥

```cpp
#include "qaultra/engine/backtest_engine.hpp"

using namespace qaultra::engine;

int main() {
    // 1. é…ç½®å›æµ‹å‚æ•°
    BacktestConfig config;
    config.start_date = "2024-01-01";
    config.end_date = "2024-12-31";
    config.initial_cash = 1000000.0;    // 100ä¸‡åˆå§‹èµ„é‡‘
    config.commission_rate = 0.0025;    // 0.25%æ‰‹ç»­è´¹
    config.benchmark = "000300";        // æ²ªæ·±300åŸºå‡†

    // 2. åˆ›å»ºå›æµ‹å¼•æ“
    BacktestEngine engine(config);

    // 3. æ·»åŠ äº¤æ˜“æ ‡çš„
    std::vector<std::string> universe = {"000001", "000002", "000858", "002415"};
    engine.set_universe(universe);

    // 4. åˆ›å»ºå’Œæ·»åŠ ç­–ç•¥
    auto sma_strategy = factory::create_sma_strategy(5, 20);  // 5æ—¥çº¿å’Œ20æ—¥çº¿
    engine.add_strategy(sma_strategy);

    // 5. åŠ è½½å¸‚åœºæ•°æ®
    engine.load_data("data/stock_data/");

    // 6. è¿è¡Œå›æµ‹
    auto results = engine.run();

    // 7. è¾“å‡ºç»“æœ
    std::cout << "=== å›æµ‹ç»“æœ ===" << std::endl;
    std::cout << "æ€»æ”¶ç›Šç‡: " << (results.total_return * 100) << "%" << std::endl;
    std::cout << "å¹´åŒ–æ”¶ç›Šç‡: " << (results.annual_return * 100) << "%" << std::endl;
    std::cout << "å¤æ™®æ¯”ç‡: " << results.sharpe_ratio << std::endl;
    std::cout << "æœ€å¤§å›æ’¤: " << (results.max_drawdown * 100) << "%" << std::endl;
    std::cout << "æ€»äº¤æ˜“æ¬¡æ•°: " << results.total_trades << std::endl;
    std::cout << "èƒœç‡: " << (results.win_rate * 100) << "%" << std::endl;

    // 8. ä¿å­˜ç»“æœ
    engine.save_results("backtest_results.json");

    return 0;
}
```

### Pythonç­–ç•¥å›æµ‹

```python
import qaultra_cpp as qa

# 1. é…ç½®å›æµ‹
config = qa.engine.BacktestConfig()
config.start_date = "2024-01-01"
config.end_date = "2024-12-31"
config.initial_cash = 1000000.0
config.commission_rate = 0.0025

# 2. åˆ›å»ºå›æµ‹å¼•æ“
engine = qa.engine.BacktestEngine(config)

# 3. è®¾ç½®è‚¡ç¥¨æ± 
universe = ["000001", "000002", "000858", "002415"]
engine.set_universe(universe)

# 4. æ·»åŠ ç­–ç•¥
sma_strategy = qa.engine.factory.create_sma_strategy(5, 20)
momentum_strategy = qa.engine.factory.create_momentum_strategy(20, 0.02)

engine.add_strategy(sma_strategy)
engine.add_strategy(momentum_strategy)

# 5. è¿è¡Œå›æµ‹
results = engine.run()

# 6. åˆ†æç»“æœ
print("=== å›æµ‹ç»“æœ ===")
print(f"æ€»æ”¶ç›Šç‡: {results.total_return*100:.2f}%")
print(f"å¹´åŒ–æ”¶ç›Šç‡: {results.annual_return*100:.2f}%")
print(f"å¤æ™®æ¯”ç‡: {results.sharpe_ratio:.3f}")
print(f"æœ€å¤§å›æ’¤: {results.max_drawdown*100:.2f}%")
print(f"æ³¢åŠ¨ç‡: {results.volatility*100:.2f}%")

# 7. å¯è§†åŒ–ç»“æœ(éœ€è¦matplotlib)
import matplotlib.pyplot as plt

equity_curve = engine.plot_equity_curve()
dates = [point[0] for point in equity_curve]
values = [point[1] for point in equity_curve]

plt.figure(figsize=(12, 8))
plt.plot(dates, values, label='ç­–ç•¥æ”¶ç›Š')
plt.title('ç­–ç•¥æƒç›Šæ›²çº¿')
plt.xlabel('æ—¥æœŸ')
plt.ylabel('æ€»èµ„äº§ (ï¿¥)')
plt.legend()
plt.grid(True)
plt.show()
```

## âš¡ æ€§èƒ½ä¼˜åŒ–æŒ‡å—

### SIMDä¼˜åŒ–ä½¿ç”¨

```cpp
#include "qaultra/simd/simd_math.hpp"

// 1. å‘é‡åŒ–æ•°å­¦è¿ç®—
std::vector<double> prices = {100.1, 100.2, 100.3, 100.4};
std::vector<double> volumes = {1000, 2000, 3000, 4000};

// SIMDä¼˜åŒ–çš„å‘é‡ä¹˜æ³•
auto amounts = simd::vectorized_multiply(prices.data(), volumes.data(), prices.size());

// 2. æŠ€æœ¯æŒ‡æ ‡è®¡ç®—
auto sma_result = simd::calculate_sma(prices.data(), prices.size(), 20);
auto ema_result = simd::calculate_ema(prices.data(), prices.size(), 0.1);

// 3. é‡‘èæŒ‡æ ‡è®¡ç®—
std::vector<double> returns = simd::calculate_returns(prices.data(), prices.size());
double sharpe = simd::calculate_sharpe_ratio_simd(returns.data(), returns.size(), 0.03);
```

### å†…å­˜ä¼˜åŒ–

```cpp
#include "qaultra/memory/object_pool.hpp"

// 1. å¯¹è±¡æ± ä½¿ç”¨
auto order_pool = std::make_shared<memory::ObjectPool<account::Order>>(10000);

// é«˜é¢‘åˆ›å»ºè®¢å•æ—¶ä½¿ç”¨å¯¹è±¡æ± 
auto order = order_pool->acquire();
order->order_id = "ORDER_001";
order->code = "000001";
// ... ä½¿ç”¨è®¢å•

order_pool->release(order);  // é‡Šæ”¾å›æ± 

// 2. å†…å­˜æ˜ å°„æ•°ç»„(é›¶æ‹·è´)
memory::MemoryMappedArray<double> large_array("data.bin", 1000000);
large_array[0] = 123.456;
large_array.sync();  // åŒæ­¥åˆ°ç£ç›˜
```

### å¤šçº¿ç¨‹ä¼˜åŒ–

```cpp
#include "qaultra/threading/lockfree_queue.hpp"

// 1. æ— é”é˜Ÿåˆ—
threading::LockFreeQueue<std::shared_ptr<account::Order>> order_queue(10000);

// ç”Ÿäº§è€…çº¿ç¨‹
std::thread producer([&]() {
    for (int i = 0; i < 1000; ++i) {
        auto order = std::make_shared<account::Order>();
        order->order_id = "ORDER_" + std::to_string(i);
        order_queue.enqueue(order);
    }
});

// æ¶ˆè´¹è€…çº¿ç¨‹
std::thread consumer([&]() {
    std::shared_ptr<account::Order> order;
    while (order_queue.dequeue(order)) {
        // å¤„ç†è®¢å•
        process_order(order);
    }
});

producer.join();
consumer.join();
```

## ğŸ“Š æ•°æ®åº“é›†æˆ

### MongoDBä½¿ç”¨

```cpp
#include "qaultra/connector/mongodb_connector.hpp"

// 1. é…ç½®MongoDBè¿æ¥
connector::MongoConfig config;
config.host = "localhost";
config.port = 27017;
config.database = "quantaxis";

auto mongo = std::make_unique<connector::MongoConnector>(config);

// 2. è¿æ¥å’Œä¿å­˜è´¦æˆ·æ•°æ®
if (mongo->connect()) {
    // ä¿å­˜è´¦æˆ·
    auto qifi = account->to_qifi();
    mongo->save_account(qifi);

    // ä¿å­˜Kçº¿æ•°æ®
    mongo->save_kline_data("stock_daily", klines);

    // æŸ¥è¯¢æ•°æ®
    connector::QueryFilter filter;
    filter.code = "000001";
    filter.start_date = "2024-01-01";
    filter.end_date = "2024-12-31";

    auto historical_data = mongo->load_kline_data("stock_daily", filter);
}
```

### ClickHouseé«˜æ€§èƒ½åˆ†æ

```cpp
#include "qaultra/connector/clickhouse_connector.hpp"

// 1. é…ç½®ClickHouseè¿æ¥
connector::ClickHouseConfig config;
config.host = "localhost";
config.port = 9000;
config.database = "quantaxis";

auto clickhouse = std::make_unique<connector::ClickHouseConnector>(config);

// 2. åˆ›å»ºè¡¨å’Œæ’å…¥æ•°æ®
if (clickhouse->connect()) {
    // åˆ›å»ºKçº¿è¡¨
    clickhouse->create_kline_table("stock_minute");

    // æ‰¹é‡æ’å…¥æ•°æ®
    clickhouse->insert_kline_data("stock_minute", klines);

    // èšåˆæŸ¥è¯¢
    auto daily_data = clickhouse->aggregate_kline_data(
        "stock_minute", "000001",
        "2024-01-01", "2024-12-31",
        connector::AggregationType::DAY_1
    );

    // æŠ€æœ¯æŒ‡æ ‡è®¡ç®—
    auto indicators = clickhouse->calculate_technical_indicators(
        "stock_minute", "000001", {"SMA", "EMA", "RSI"}, 20
    );
}
```

## ğŸ› ï¸ è‡ªå®šä¹‰ç­–ç•¥å¼€å‘

### C++ç­–ç•¥

```cpp
#include "qaultra/engine/backtest_engine.hpp"

class MyCustomStrategy : public engine::Strategy {
public:
    // ç­–ç•¥å‚æ•°
    int short_period = 5;
    int long_period = 20;
    double threshold = 0.02;

    void initialize(engine::StrategyContext& context) override {
        context.log("åˆå§‹åŒ–è‡ªå®šä¹‰ç­–ç•¥");
        // åˆå§‹åŒ–é€»è¾‘
    }

    void handle_data(engine::StrategyContext& context) override {
        for (const auto& symbol : context.universe) {
            // è·å–å†å²ä»·æ ¼
            auto short_prices = context.get_history(symbol, short_period, "close");
            auto long_prices = context.get_history(symbol, long_period, "close");

            if (short_prices.size() < short_period || long_prices.size() < long_period) {
                continue;
            }

            // è®¡ç®—ç§»åŠ¨å¹³å‡
            double short_ma = std::accumulate(short_prices.begin(), short_prices.end(), 0.0) / short_period;
            double long_ma = std::accumulate(long_prices.begin(), long_prices.end(), 0.0) / long_period;

            double current_price = context.get_price(symbol);
            auto position = context.get_position(symbol);

            // äº¤æ˜“ä¿¡å·
            double signal = (short_ma - long_ma) / long_ma;

            if (signal > threshold && (!position || position->volume_long == 0)) {
                // ä¹°å…¥ä¿¡å·
                double cash = context.get_cash();
                double shares = std::floor(cash * 0.2 / current_price / 100) * 100;

                if (shares >= 100) {
                    auto order = context.account->buy(symbol, shares, context.current_date, current_price);
                    context.log("ä¹°å…¥ " + symbol + " " + std::to_string(shares) + "è‚¡");
                }
            } else if (signal < -threshold && position && position->volume_long > 0) {
                // å–å‡ºä¿¡å·
                auto order = context.account->sell(symbol, position->volume_long, context.current_date, current_price);
                context.log("å–å‡º " + symbol + " " + std::to_string(position->volume_long) + "è‚¡");
            }
        }
    }

    std::string get_name() const override {
        return "è‡ªå®šä¹‰å‡çº¿ç­–ç•¥";
    }

    std::map<std::string, double> get_parameters() const override {
        return {
            {"short_period", static_cast<double>(short_period)},
            {"long_period", static_cast<double>(long_period)},
            {"threshold", threshold}
        };
    }

    void set_parameter(const std::string& name, double value) override {
        if (name == "short_period") {
            short_period = static_cast<int>(value);
        } else if (name == "long_period") {
            long_period = static_cast<int>(value);
        } else if (name == "threshold") {
            threshold = value;
        }
    }
};
```

### Pythonç­–ç•¥æ‰©å±•

```python
import qaultra_cpp as qa
import numpy as np

class PythonStrategy(qa.engine.Strategy):
    def __init__(self):
        super().__init__()
        self.lookback = 20
        self.threshold = 0.02

    def initialize(self, context):
        context.log("åˆå§‹åŒ–Pythonç­–ç•¥")
        self.price_history = {}

    def handle_data(self, context):
        for symbol in context.universe:
            # è·å–ä»·æ ¼å†å²
            prices = context.get_history(symbol, self.lookback, "close")
            if len(prices) < self.lookback:
                continue

            # è®¡ç®—Zåˆ†æ•°(æ ‡å‡†åŒ–)
            mean_price = np.mean(prices)
            std_price = np.std(prices)
            current_price = context.get_price(symbol)

            if std_price > 0:
                z_score = (current_price - mean_price) / std_price

                position = context.get_position(symbol)

                # å‡å€¼å›å½’ç­–ç•¥
                if z_score < -self.threshold and not position:
                    # ä»·æ ¼è¿‡ä½ï¼Œä¹°å…¥
                    cash = context.get_cash()
                    shares = int(cash * 0.1 / current_price / 100) * 100

                    if shares >= 100:
                        context.account.buy(symbol, shares, context.current_date, current_price)
                        context.log(f"å‡å€¼å›å½’ä¹°å…¥ {symbol}: Zåˆ†æ•°={z_score:.3f}")

                elif z_score > self.threshold and position and position.volume_long > 0:
                    # ä»·æ ¼è¿‡é«˜ï¼Œå–å‡º
                    context.account.sell(symbol, position.volume_long, context.current_date, current_price)
                    context.log(f"å‡å€¼å›å½’å–å‡º {symbol}: Zåˆ†æ•°={z_score:.3f}")

    def get_name(self):
        return "Pythonå‡å€¼å›å½’ç­–ç•¥"

    def get_parameters(self):
        return {"lookback": self.lookback, "threshold": self.threshold}

    def set_parameter(self, name, value):
        if name == "lookback":
            self.lookback = int(value)
        elif name == "threshold":
            self.threshold = float(value)
```

## ğŸ“ˆ æ€§èƒ½ç›‘æ§

### å®æ—¶ç›‘æ§

```cpp
#include "qaultra/analysis/performance.hpp"

// 1. åˆ›å»ºå®æ—¶ç›‘æ§å™¨
auto monitor = std::make_unique<analysis::RealTimePerformanceMonitor>(account);

// 2. è®¾ç½®å›è°ƒ
monitor->set_update_callback([](const analysis::PerformanceMetrics& metrics) {
    std::cout << "å®æ—¶å¤æ™®æ¯”ç‡: " << metrics.sharpe_ratio << std::endl;
    std::cout << "å½“å‰å›æ’¤: " << (metrics.max_drawdown * 100) << "%" << std::endl;
});

// 3. è®¾ç½®é£é™©è­¦å‘Š
monitor->set_risk_warning_callback([](const std::string& warning, double value) {
    std::cout << "é£é™©è­¦å‘Š: " << warning << " = " << value << std::endl;
});

// 4. è®¾ç½®é£é™©é˜ˆå€¼
monitor->set_risk_thresholds(0.15, 0.5);  // 15%æœ€å¤§å›æ’¤ï¼Œ0.5æœ€å°å¤æ™®æ¯”ç‡

// 5. å¼€å§‹ç›‘æ§
monitor->start_monitoring();
```

## â“ å¸¸è§é—®é¢˜

### Q: å¦‚ä½•å¯ç”¨æœ€é«˜æ€§èƒ½æ¨¡å¼ï¼Ÿ

A: ç¼–è¯‘æ—¶ä½¿ç”¨ä»¥ä¸‹CMakeé€‰é¡¹ï¼š

```bash
cmake .. \
    -DCMAKE_BUILD_TYPE=Release \
    -DQAULTRA_ENABLE_SIMD=ON \
    -DQAULTRA_ENABLE_NATIVE=ON \
    -DQAULTRA_ENABLE_LTO=ON \
    -DQAULTRA_ENABLE_MIMALLOC=ON
```

### Q: å¦‚ä½•å¤„ç†å¤§è§„æ¨¡æ•°æ®ï¼Ÿ

A: ä½¿ç”¨å†…å­˜æ˜ å°„å’Œæµå¼å¤„ç†ï¼š

```cpp
// 1. å†…å­˜æ˜ å°„å¤§æ–‡ä»¶
memory::MemoryMappedArray<double> big_data("large_file.bin", 100000000);

// 2. æµå¼æ’å…¥ClickHouse
clickhouse->start_streaming_insert("large_table");
for (const auto& record : records) {
    clickhouse->stream_insert_kline(record);
}
clickhouse->finish_streaming_insert();
```

### Q: å¦‚ä½•ä¼˜åŒ–ç­–ç•¥å›æµ‹é€Ÿåº¦ï¼Ÿ

A: ä½¿ç”¨ä»¥ä¸‹ä¼˜åŒ–æŠ€å·§ï¼š

```cpp
// 1. å¯ç”¨å¹¶è¡Œå¤„ç†
BacktestConfig config;
config.max_threads = std::thread::hardware_concurrency();
config.enable_matching_engine = false;  // ç®€åŒ–æ¨¡å¼

// 2. é¢„åˆ†é…å†…å­˜
strategy->reserve_memory(expected_trades);

// 3. ä½¿ç”¨SIMDä¼˜åŒ–æŒ‡æ ‡
auto fast_sma = simd::calculate_sma(prices.data(), prices.size(), 20);
```

### Q: å¦‚ä½•é›†æˆå®æ—¶æ•°æ®æºï¼Ÿ

A: å®ç°MarketDataFeedæ¥å£ï¼š

```cpp
class MyDataFeed : public market::MarketDataFeed {
public:
    bool subscribe(const std::string& symbol) override {
        // è¿æ¥å®æ—¶æ•°æ®æº
        return websocket_client->subscribe(symbol);
    }

    void add_callback(EventCallback callback) override {
        callbacks_.push_back(callback);
    }

private:
    void on_market_data(const MarketEvent& event) {
        for (auto& callback : callbacks_) {
            callback(event);
        }
    }
};
```

## ğŸ“§ æ”¯æŒå’Œç¤¾åŒº

- **æ–‡æ¡£**: [https://qaultra-cpp.readthedocs.io](https://qaultra-cpp.readthedocs.io)
- **é—®é¢˜åé¦ˆ**: [GitHub Issues](https://github.com/quantaxis/qaultra-cpp/issues)
- **è®¨è®º**: [GitHub Discussions](https://github.com/quantaxis/qaultra-cpp/discussions)
- **QQç¾¤**: 563280067 (QUANTAXIS)
- **å¾®ä¿¡ç¾¤**: æ‰«æäºŒç»´ç åŠ å…¥

## ğŸ“ è®¸å¯è¯

æœ¬é¡¹ç›®åŸºäº MIT è®¸å¯è¯å¼€æº - æŸ¥çœ‹ [LICENSE](LICENSE) æ–‡ä»¶äº†è§£è¯¦æƒ…ã€‚

## ğŸ™ è‡´è°¢

- **QUANTAXIS**: åŸå§‹Pythoné‡åŒ–äº¤æ˜“æ¡†æ¶
- **QARS**: å¯å‘æ­¤ç§»æ¤çš„Rustå®ç°
- **Apache Arrow**: é«˜æ€§èƒ½åˆ—å¼æ•°æ®å¤„ç†
- **Intel TBB**: å¹¶è¡ŒåŒ–æ„å»ºå—
- **pybind11**: Pythonç»‘å®šæ¡†æ¶

---

**QAULTRA C++** - é«˜æ€§èƒ½é‡åŒ–äº¤æ˜“çš„ç»ˆæé€‰æ‹©