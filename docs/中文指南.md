# QAULTRA C++ 中文使用指南

## 📖 目录

- [系统架构](#系统架构)
- [安装指南](#安装指南)
- [快速开始](#快速开始)
- [模块详解](#模块详解)
- [API参考](#api参考)
- [性能优化](#性能优化)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

## 🏗️ 系统架构

QAULTRA C++ 采用模块化设计，主要组件包括：

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Python API    │    │   C++ 核心      │    │   原生库        │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • 账户管理      │◄──►│ • QA_Account    │◄──►│ • Apache Arrow  │
│ • 策略开发      │    │ • MatchEngine   │    │ • Intel TBB     │
│ • 回测分析      │    │ • MarketData    │    │ • mimalloc      │
│ • 数据分析      │    │ • 协议支持      │    │ • SIMD 内在函数 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 核心模块

#### 🏦 账户系统 (`qaultra::account`)
- **QA_Account**: 主要交易账户类，支持股票和期货交易
- **Position**: 多资产持仓跟踪，实时盈亏计算
- **Order**: 订单生命周期管理，支持多种订单类型
- **MarketPreset**: 市场特定配置，手续费和保证金设置

#### 📊 市场数据 (`qaultra::market`)
- **MatchingEngine**: 高性能订单撮合引擎
- **OrderBook**: Level-2市场深度数据
- **MarketDataFeed**: 实时数据接入
- **MarketSimulator**: 回测市场模拟

#### 💾 数据结构 (`qaultra::data`)
- **ArrowKlineCollection**: 列式OHLCV数据存储
- **KlineCollection**: 传统K线数据存储
- **MarketDataManager**: 多标的数据管理

#### 🔌 协议支持 (`qaultra::protocol`)
- **QIFI**: 账户和投资组合序列化
- **MIFI**: 市场数据格式
- **TIFI**: 交易信息交换

## 📦 安装指南

### 系统要求

- **C++20** 兼容编译器 (GCC 10+, Clang 12+, MSVC 2019+)
- **CMake** 3.20 或更高版本
- **Python** 3.8+ (用于Python绑定)

### Ubuntu/Debian 安装

```bash
# 1. 安装系统依赖
sudo apt-get update
sudo apt-get install -y \
    build-essential \
    cmake \
    ninja-build \
    pkg-config \
    libtbb-dev \
    libssl-dev \
    python3-dev \
    python3-pip

# 2. 克隆仓库
git clone https://github.com/quantaxis/qaultra-cpp.git
cd qaultra-cpp

# 3. 创建构建目录
mkdir build && cd build

# 4. 配置CMake (启用所有优化)
cmake .. \
    -DCMAKE_BUILD_TYPE=Release \
    -DQAULTRA_ENABLE_SIMD=ON \
    -DQAULTRA_ENABLE_NATIVE=ON \
    -DQAULTRA_ENABLE_LTO=ON \
    -DQAULTRA_BUILD_PYTHON_BINDINGS=ON \
    -G Ninja

# 5. 编译
ninja -j$(nproc)

# 6. 安装Python包
pip install -e python/
```

### macOS 安装

```bash
# 1. 安装Homebrew依赖
brew install cmake ninja tbb python@3.11

# 2. 设置编译环境
export CXX=clang++
export CC=clang

# 3. 按照上述Ubuntu步骤继续
```

### Windows (MSVC) 安装

```batch
# 1. 安装Visual Studio 2019/2022
# 2. 安装CMake和vcpkg

# 3. 使用vcpkg安装依赖
vcpkg install tbb:x64-windows arrow:x64-windows

# 4. 配置和构建
cmake -B build -DCMAKE_TOOLCHAIN_FILE=vcpkg/scripts/buildsystems/vcpkg.cmake
cmake --build build --config Release
```

### Docker安装

```bash
# 使用官方Docker镜像
docker pull quantaxis/qaultra-cpp:latest

# 或构建本地镜像
docker build -t qaultra-cpp .
docker run -it qaultra-cpp bash
```

## 🚀 快速开始

### C++基础用法

```cpp
#include "qaultra/qaultra.hpp"

using namespace qaultra;

int main() {
    // 1. 创建交易账户
    auto account = std::make_shared<account::QA_Account>(
        "我的账户",           // 账户ID
        "投资组合1",         // 组合ID
        "用户123",           // 用户ID
        1000000.0,          // 初始资金 (100万)
        false,              // 是否自动补仓
        "backtest"          // 环境类型 (backtest/real)
    );

    std::cout << "初始资金: ￥" << account->get_cash() << std::endl;

    // 2. 执行买入操作
    auto buy_order = account->buy(
        "000001",           // 股票代码
        1000.0,            // 买入数量
        "2024-01-15 09:30:00", // 交易时间
        10.50              // 买入价格
    );

    std::cout << "订单状态: " << static_cast<int>(buy_order->status) << std::endl;
    std::cout << "账户余额: ￥" << account->get_cash() << std::endl;

    // 3. 价格更新
    account->on_price_change("000001", 11.00, "2024-01-15 15:00:00");

    std::cout << "浮动盈亏: ￥" << account->get_float_profit() << std::endl;
    std::cout << "总资产: ￥" << account->get_total_value() << std::endl;

    // 4. 导出QIFI格式
    auto qifi_data = account->to_qifi();
    std::cout << "持仓数量: " << qifi_data.positions.size() << std::endl;

    return 0;
}
```

### Python高级用法

```python
import qaultra_cpp as qa
import numpy as np
import pandas as pd

# 1. 创建账户
account = qa.account.QA_Account(
    account_cookie="python账户",
    portfolio_cookie="python组合",
    user_cookie="python用户",
    init_cash=1000000.0,
    auto_reload=False,
    environment="backtest"
)

print(f"初始资金: ￥{account.get_cash():,.2f}")

# 2. 创建Arrow K线数据
klines = qa.data.ArrowKlineCollection()

# 生成示例数据
dates = pd.date_range('2024-01-01', periods=100, freq='D')
codes = ["000001"] * 100
timestamps = [int(d.timestamp() * 1000) for d in dates]

# 模拟价格数据
np.random.seed(42)
prices = 10.0 + np.cumsum(np.random.normal(0, 0.1, 100))
opens = prices
closes = prices + np.random.normal(0, 0.05, 100)
highs = np.maximum(opens, closes) + np.abs(np.random.normal(0, 0.1, 100))
lows = np.minimum(opens, closes) - np.abs(np.random.normal(0, 0.1, 100))
volumes = np.random.uniform(100000, 500000, 100)
amounts = closes * volumes

# 添加到Arrow集合
klines.add_batch(codes, timestamps, opens.tolist(), highs.tolist(),
                lows.tolist(), closes.tolist(), volumes.tolist(), amounts.tolist())

print(f"K线数据条数: {klines.size()}")

# 3. 技术指标计算(SIMD优化)
sma_20 = klines.sma(20)  # 20日简单移动平均
ema_12 = klines.ema(0.154)  # 12日指数移动平均 (alpha=2/(12+1))
rsi_14 = klines.rsi(14)  # 14日RSI

print(f"SMA(20)最新值: {sma_20[-1]:.2f}")
print(f"EMA(12)最新值: {ema_12[-1]:.2f}")
print(f"RSI(14)最新值: {rsi_14[-1]:.2f}")

# 4. 执行交易
current_price = closes[-1]
buy_order = account.buy("000001", 1000, "2024-04-10 09:30:00", current_price)

print(f"买入订单: {1000}股 @ ￥{current_price:.2f}")
print(f"订单状态: {buy_order.status}")

# 5. 价格更新和盈亏计算
new_price = current_price * 1.05  # 上涨5%
account.on_price_change("000001", new_price, "2024-04-10 15:00:00")

print(f"价格更新: ￥{current_price:.2f} → ￥{new_price:.2f}")
print(f"浮动盈亏: ￥{account.get_float_profit():,.2f}")
print(f"总资产: ￥{account.get_total_value():,.2f}")

# 6. 性能测试 - SIMD vs 标准实现
size = 1000000
a = np.random.random(size)
b = np.random.random(size)

import time

# 标准NumPy
start = time.time()
numpy_result = a * b
numpy_time = time.time() - start

# SIMD优化
start = time.time()
simd_result = qa.simd.vectorized_multiply(a, b)
simd_time = time.time() - start

print(f"\n性能对比 ({size:,}个元素):")
print(f"NumPy实现: {numpy_time:.4f}秒")
print(f"SIMD实现: {simd_time:.4f}秒")
print(f"性能提升: {numpy_time/simd_time:.2f}倍")
```

## 🔧 回测示例

### 简单移动平均策略

```cpp
#include "qaultra/engine/backtest_engine.hpp"

using namespace qaultra::engine;

int main() {
    // 1. 配置回测参数
    BacktestConfig config;
    config.start_date = "2024-01-01";
    config.end_date = "2024-12-31";
    config.initial_cash = 1000000.0;    // 100万初始资金
    config.commission_rate = 0.0025;    // 0.25%手续费
    config.benchmark = "000300";        // 沪深300基准

    // 2. 创建回测引擎
    BacktestEngine engine(config);

    // 3. 添加交易标的
    std::vector<std::string> universe = {"000001", "000002", "000858", "002415"};
    engine.set_universe(universe);

    // 4. 创建和添加策略
    auto sma_strategy = factory::create_sma_strategy(5, 20);  // 5日线和20日线
    engine.add_strategy(sma_strategy);

    // 5. 加载市场数据
    engine.load_data("data/stock_data/");

    // 6. 运行回测
    auto results = engine.run();

    // 7. 输出结果
    std::cout << "=== 回测结果 ===" << std::endl;
    std::cout << "总收益率: " << (results.total_return * 100) << "%" << std::endl;
    std::cout << "年化收益率: " << (results.annual_return * 100) << "%" << std::endl;
    std::cout << "夏普比率: " << results.sharpe_ratio << std::endl;
    std::cout << "最大回撤: " << (results.max_drawdown * 100) << "%" << std::endl;
    std::cout << "总交易次数: " << results.total_trades << std::endl;
    std::cout << "胜率: " << (results.win_rate * 100) << "%" << std::endl;

    // 8. 保存结果
    engine.save_results("backtest_results.json");

    return 0;
}
```

### Python策略回测

```python
import qaultra_cpp as qa

# 1. 配置回测
config = qa.engine.BacktestConfig()
config.start_date = "2024-01-01"
config.end_date = "2024-12-31"
config.initial_cash = 1000000.0
config.commission_rate = 0.0025

# 2. 创建回测引擎
engine = qa.engine.BacktestEngine(config)

# 3. 设置股票池
universe = ["000001", "000002", "000858", "002415"]
engine.set_universe(universe)

# 4. 添加策略
sma_strategy = qa.engine.factory.create_sma_strategy(5, 20)
momentum_strategy = qa.engine.factory.create_momentum_strategy(20, 0.02)

engine.add_strategy(sma_strategy)
engine.add_strategy(momentum_strategy)

# 5. 运行回测
results = engine.run()

# 6. 分析结果
print("=== 回测结果 ===")
print(f"总收益率: {results.total_return*100:.2f}%")
print(f"年化收益率: {results.annual_return*100:.2f}%")
print(f"夏普比率: {results.sharpe_ratio:.3f}")
print(f"最大回撤: {results.max_drawdown*100:.2f}%")
print(f"波动率: {results.volatility*100:.2f}%")

# 7. 可视化结果(需要matplotlib)
import matplotlib.pyplot as plt

equity_curve = engine.plot_equity_curve()
dates = [point[0] for point in equity_curve]
values = [point[1] for point in equity_curve]

plt.figure(figsize=(12, 8))
plt.plot(dates, values, label='策略收益')
plt.title('策略权益曲线')
plt.xlabel('日期')
plt.ylabel('总资产 (￥)')
plt.legend()
plt.grid(True)
plt.show()
```

## ⚡ 性能优化指南

### SIMD优化使用

```cpp
#include "qaultra/simd/simd_math.hpp"

// 1. 向量化数学运算
std::vector<double> prices = {100.1, 100.2, 100.3, 100.4};
std::vector<double> volumes = {1000, 2000, 3000, 4000};

// SIMD优化的向量乘法
auto amounts = simd::vectorized_multiply(prices.data(), volumes.data(), prices.size());

// 2. 技术指标计算
auto sma_result = simd::calculate_sma(prices.data(), prices.size(), 20);
auto ema_result = simd::calculate_ema(prices.data(), prices.size(), 0.1);

// 3. 金融指标计算
std::vector<double> returns = simd::calculate_returns(prices.data(), prices.size());
double sharpe = simd::calculate_sharpe_ratio_simd(returns.data(), returns.size(), 0.03);
```

### 内存优化

```cpp
#include "qaultra/memory/object_pool.hpp"

// 1. 对象池使用
auto order_pool = std::make_shared<memory::ObjectPool<account::Order>>(10000);

// 高频创建订单时使用对象池
auto order = order_pool->acquire();
order->order_id = "ORDER_001";
order->code = "000001";
// ... 使用订单

order_pool->release(order);  // 释放回池

// 2. 内存映射数组(零拷贝)
memory::MemoryMappedArray<double> large_array("data.bin", 1000000);
large_array[0] = 123.456;
large_array.sync();  // 同步到磁盘
```

### 多线程优化

```cpp
#include "qaultra/threading/lockfree_queue.hpp"

// 1. 无锁队列
threading::LockFreeQueue<std::shared_ptr<account::Order>> order_queue(10000);

// 生产者线程
std::thread producer([&]() {
    for (int i = 0; i < 1000; ++i) {
        auto order = std::make_shared<account::Order>();
        order->order_id = "ORDER_" + std::to_string(i);
        order_queue.enqueue(order);
    }
});

// 消费者线程
std::thread consumer([&]() {
    std::shared_ptr<account::Order> order;
    while (order_queue.dequeue(order)) {
        // 处理订单
        process_order(order);
    }
});

producer.join();
consumer.join();
```

## 📊 数据库集成

### MongoDB使用

```cpp
#include "qaultra/connector/mongodb_connector.hpp"

// 1. 配置MongoDB连接
connector::MongoConfig config;
config.host = "localhost";
config.port = 27017;
config.database = "quantaxis";

auto mongo = std::make_unique<connector::MongoConnector>(config);

// 2. 连接和保存账户数据
if (mongo->connect()) {
    // 保存账户
    auto qifi = account->to_qifi();
    mongo->save_account(qifi);

    // 保存K线数据
    mongo->save_kline_data("stock_daily", klines);

    // 查询数据
    connector::QueryFilter filter;
    filter.code = "000001";
    filter.start_date = "2024-01-01";
    filter.end_date = "2024-12-31";

    auto historical_data = mongo->load_kline_data("stock_daily", filter);
}
```

### ClickHouse高性能分析

```cpp
#include "qaultra/connector/clickhouse_connector.hpp"

// 1. 配置ClickHouse连接
connector::ClickHouseConfig config;
config.host = "localhost";
config.port = 9000;
config.database = "quantaxis";

auto clickhouse = std::make_unique<connector::ClickHouseConnector>(config);

// 2. 创建表和插入数据
if (clickhouse->connect()) {
    // 创建K线表
    clickhouse->create_kline_table("stock_minute");

    // 批量插入数据
    clickhouse->insert_kline_data("stock_minute", klines);

    // 聚合查询
    auto daily_data = clickhouse->aggregate_kline_data(
        "stock_minute", "000001",
        "2024-01-01", "2024-12-31",
        connector::AggregationType::DAY_1
    );

    // 技术指标计算
    auto indicators = clickhouse->calculate_technical_indicators(
        "stock_minute", "000001", {"SMA", "EMA", "RSI"}, 20
    );
}
```

## 🛠️ 自定义策略开发

### C++策略

```cpp
#include "qaultra/engine/backtest_engine.hpp"

class MyCustomStrategy : public engine::Strategy {
public:
    // 策略参数
    int short_period = 5;
    int long_period = 20;
    double threshold = 0.02;

    void initialize(engine::StrategyContext& context) override {
        context.log("初始化自定义策略");
        // 初始化逻辑
    }

    void handle_data(engine::StrategyContext& context) override {
        for (const auto& symbol : context.universe) {
            // 获取历史价格
            auto short_prices = context.get_history(symbol, short_period, "close");
            auto long_prices = context.get_history(symbol, long_period, "close");

            if (short_prices.size() < short_period || long_prices.size() < long_period) {
                continue;
            }

            // 计算移动平均
            double short_ma = std::accumulate(short_prices.begin(), short_prices.end(), 0.0) / short_period;
            double long_ma = std::accumulate(long_prices.begin(), long_prices.end(), 0.0) / long_period;

            double current_price = context.get_price(symbol);
            auto position = context.get_position(symbol);

            // 交易信号
            double signal = (short_ma - long_ma) / long_ma;

            if (signal > threshold && (!position || position->volume_long == 0)) {
                // 买入信号
                double cash = context.get_cash();
                double shares = std::floor(cash * 0.2 / current_price / 100) * 100;

                if (shares >= 100) {
                    auto order = context.account->buy(symbol, shares, context.current_date, current_price);
                    context.log("买入 " + symbol + " " + std::to_string(shares) + "股");
                }
            } else if (signal < -threshold && position && position->volume_long > 0) {
                // 卖出信号
                auto order = context.account->sell(symbol, position->volume_long, context.current_date, current_price);
                context.log("卖出 " + symbol + " " + std::to_string(position->volume_long) + "股");
            }
        }
    }

    std::string get_name() const override {
        return "自定义均线策略";
    }

    std::map<std::string, double> get_parameters() const override {
        return {
            {"short_period", static_cast<double>(short_period)},
            {"long_period", static_cast<double>(long_period)},
            {"threshold", threshold}
        };
    }

    void set_parameter(const std::string& name, double value) override {
        if (name == "short_period") {
            short_period = static_cast<int>(value);
        } else if (name == "long_period") {
            long_period = static_cast<int>(value);
        } else if (name == "threshold") {
            threshold = value;
        }
    }
};
```

### Python策略扩展

```python
import qaultra_cpp as qa
import numpy as np

class PythonStrategy(qa.engine.Strategy):
    def __init__(self):
        super().__init__()
        self.lookback = 20
        self.threshold = 0.02

    def initialize(self, context):
        context.log("初始化Python策略")
        self.price_history = {}

    def handle_data(self, context):
        for symbol in context.universe:
            # 获取价格历史
            prices = context.get_history(symbol, self.lookback, "close")
            if len(prices) < self.lookback:
                continue

            # 计算Z分数(标准化)
            mean_price = np.mean(prices)
            std_price = np.std(prices)
            current_price = context.get_price(symbol)

            if std_price > 0:
                z_score = (current_price - mean_price) / std_price

                position = context.get_position(symbol)

                # 均值回归策略
                if z_score < -self.threshold and not position:
                    # 价格过低，买入
                    cash = context.get_cash()
                    shares = int(cash * 0.1 / current_price / 100) * 100

                    if shares >= 100:
                        context.account.buy(symbol, shares, context.current_date, current_price)
                        context.log(f"均值回归买入 {symbol}: Z分数={z_score:.3f}")

                elif z_score > self.threshold and position and position.volume_long > 0:
                    # 价格过高，卖出
                    context.account.sell(symbol, position.volume_long, context.current_date, current_price)
                    context.log(f"均值回归卖出 {symbol}: Z分数={z_score:.3f}")

    def get_name(self):
        return "Python均值回归策略"

    def get_parameters(self):
        return {"lookback": self.lookback, "threshold": self.threshold}

    def set_parameter(self, name, value):
        if name == "lookback":
            self.lookback = int(value)
        elif name == "threshold":
            self.threshold = float(value)
```

## 📈 性能监控

### 实时监控

```cpp
#include "qaultra/analysis/performance.hpp"

// 1. 创建实时监控器
auto monitor = std::make_unique<analysis::RealTimePerformanceMonitor>(account);

// 2. 设置回调
monitor->set_update_callback([](const analysis::PerformanceMetrics& metrics) {
    std::cout << "实时夏普比率: " << metrics.sharpe_ratio << std::endl;
    std::cout << "当前回撤: " << (metrics.max_drawdown * 100) << "%" << std::endl;
});

// 3. 设置风险警告
monitor->set_risk_warning_callback([](const std::string& warning, double value) {
    std::cout << "风险警告: " << warning << " = " << value << std::endl;
});

// 4. 设置风险阈值
monitor->set_risk_thresholds(0.15, 0.5);  // 15%最大回撤，0.5最小夏普比率

// 5. 开始监控
monitor->start_monitoring();
```

## ❓ 常见问题

### Q: 如何启用最高性能模式？

A: 编译时使用以下CMake选项：

```bash
cmake .. \
    -DCMAKE_BUILD_TYPE=Release \
    -DQAULTRA_ENABLE_SIMD=ON \
    -DQAULTRA_ENABLE_NATIVE=ON \
    -DQAULTRA_ENABLE_LTO=ON \
    -DQAULTRA_ENABLE_MIMALLOC=ON
```

### Q: 如何处理大规模数据？

A: 使用内存映射和流式处理：

```cpp
// 1. 内存映射大文件
memory::MemoryMappedArray<double> big_data("large_file.bin", 100000000);

// 2. 流式插入ClickHouse
clickhouse->start_streaming_insert("large_table");
for (const auto& record : records) {
    clickhouse->stream_insert_kline(record);
}
clickhouse->finish_streaming_insert();
```

### Q: 如何优化策略回测速度？

A: 使用以下优化技巧：

```cpp
// 1. 启用并行处理
BacktestConfig config;
config.max_threads = std::thread::hardware_concurrency();
config.enable_matching_engine = false;  // 简化模式

// 2. 预分配内存
strategy->reserve_memory(expected_trades);

// 3. 使用SIMD优化指标
auto fast_sma = simd::calculate_sma(prices.data(), prices.size(), 20);
```

### Q: 如何集成实时数据源？

A: 实现MarketDataFeed接口：

```cpp
class MyDataFeed : public market::MarketDataFeed {
public:
    bool subscribe(const std::string& symbol) override {
        // 连接实时数据源
        return websocket_client->subscribe(symbol);
    }

    void add_callback(EventCallback callback) override {
        callbacks_.push_back(callback);
    }

private:
    void on_market_data(const MarketEvent& event) {
        for (auto& callback : callbacks_) {
            callback(event);
        }
    }
};
```

## 📧 支持和社区

- **文档**: [https://qaultra-cpp.readthedocs.io](https://qaultra-cpp.readthedocs.io)
- **问题反馈**: [GitHub Issues](https://github.com/quantaxis/qaultra-cpp/issues)
- **讨论**: [GitHub Discussions](https://github.com/quantaxis/qaultra-cpp/discussions)
- **QQ群**: 563280067 (QUANTAXIS)
- **微信群**: 扫描二维码加入

## 📝 许可证

本项目基于 MIT 许可证开源 - 查看 [LICENSE](LICENSE) 文件了解详情。

## 🙏 致谢

- **QUANTAXIS**: 原始Python量化交易框架
- **QARS**: 启发此移植的Rust实现
- **Apache Arrow**: 高性能列式数据处理
- **Intel TBB**: 并行化构建块
- **pybind11**: Python绑定框架

---

**QAULTRA C++** - 高性能量化交易的终极选择